---
title: 归并排序
date: 2025-11-26 22:42:00
tags: [C++, C, sort]
---

> leetcode第912题，排序数组：https://leetcode.cn/problems/sort-an-array/description/，每次忘了排序算法就在这里刷，哈哈

## C++

```c
class Solution {
public:
    // 合并两个有序区间：a[l .. mid] 和 a[mid+1 .. r]
    void mergeArray(vector<int>& nums, int left, int mid, int right) {
        int n1 = mid - left + 1;
        int n2 = right - mid;
        vector<int> leftarray(n1);
        vector<int> rightarray(n2);

        // 拷贝数据
        for (int i = 0; i < n1; ++i) {
            leftarray[i] = nums[left+i];
        }
        for (int j = 0; j < n2; ++j) {
            rightarray[j] = nums[mid + 1 + j];
        }

        int i = 0, j = 0, k = left;
        // 合并
        while (i < n1 && j < n2) {
            if (leftarray[i] < rightarray[j]) {
                nums[k++] = leftarray[i++];
            } else {
                nums[k++] = rightarray[j++];
            }
        }

        while (i < n1) {
            nums[k++] = leftarray[i++];
        }
        while (j < n2) {
            nums[k++] = rightarray[j++];
        }
    }

    void mergeSort(vector<int>& nums, int left, int right) {
       if (left < right) {
            int mid = left + (right - left) / 2;
            mergeSort(nums, left, mid);
            mergeSort(nums, mid+1, right);
            mergeArray(nums, left, mid, right);
       }
    }

    vector<int> sortArray(vector<int>& nums) {
        int n = nums.size();
        mergeSort(nums, 0, n-1);

        return nums;
    }
};
```

## C

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */

// 合并两个有序区间：a[l..mid] 和 a[mid+1..r]
void mergeArray(int a[], int l, int mid, int r) {
    int n1 = mid - l + 1;
    int n2 = r - mid;

    // 临时数组
    int left[n1];
    int right[n2];

    for (int i = 0; i < n1; i++) left[i] = a[l + i];
    for (int i = 0; i < n2; i++) right[i] = a[mid + 1 + i];

    int i = 0, j = 0, k = l;

    // 合并两个有序数组
    while (i < n1 && j < n2) {
        if (left[i] <= right[j])
            a[k++] = left[i++];
        else
            a[k++] = right[j++];
    }

    // 拷贝剩余部分
    while (i < n1) a[k++] = left[i++];
    while (j < n2) a[k++] = right[j++];
}

// 递归归并排序
void mergeSort(int a[], int l, int r) {
    if (l >= r) return;

    int mid = l + (r - l) / 2;

    mergeSort(a, l, mid);      // 排左半部分
    mergeSort(a, mid + 1, r);  // 排右半部分
    mergeArray(a, l, mid, r);  // 合并
}

int* sortArray(int* nums, int numsSize, int* returnSize) {
    mergeSort(nums, 0, numsSize-1);
    *returnSize = numsSize;

    return nums;
}
```
