---
title: 快速排序
date: 2025-11-26 21:56:24
tags: [C++, C, sort]
---

> leetcode第912题，排序数组：https://leetcode.cn/problems/sort-an-array/description/，每次忘了排序算法就在这里刷，哈哈

> 基于Hoare Partition（霍尔分区法），是 快速排序（Quick Sort）中一种最经典、最有效的分区算法，由快速排序发明者 Tony Hoare 提出的。但它返回的j不一定是pivot的最终位置，最终：所有 <= pivot 的元素都落在区间 [left, j]，所有 >= pivot 的元素都落在区间 [j+1, right]

## C++

```c
class Solution {
public:
    int partition(vector<int>& nums, int left, int right) {
        int mid = left + rand() % (right - left + 1);
        int pivot = nums[mid];
        swap(nums[mid], nums[left]);

        int i = left - 1;
        int j = right + 1;

        while (true) {
            do {
                ++i;
            } while (nums[i] < pivot);

            do {
                --j;
            } while (nums[j] > pivot);

            if (i >= j) break;

            swap(nums[i], nums[j]);
        }

        return j;
    }

    void quickSort(vector<int>& nums, int left, int right) {
        if (left < right) {
            int mid = partition(nums, left, right);
            quickSort(nums, left, mid);
            quickSort(nums, mid+1, right);
        }
    }

    vector<int> sortArray(vector<int>& nums) {
        int n = nums.size();
       quickSort(nums, 0, n-1);

        return nums;
    }
};
```

## C

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */

#define SWAP(a, b) do { int (tmp) = (a); (a) = (b); (b) = (tmp); } while (0);

int partition(int* nums, int left, int right) {
    int mid = left + rand() % (right - left + 1);
    int pivot = nums[mid];

    int i = left - 1;
    int j = right + 1;
    
    while (true) {
        do {
            ++i;
        } while (nums[i] < pivot);

        do {
            --j;
        } while (nums[j] > pivot);

        if (i >= j) break;

        SWAP(nums[i], nums[j]);
    }

    return j;
}

void quickSort(int* nums, int left, int right) {
    if (left < right) {
        int mid = partition(nums, left, right);
        quickSort(nums, left, mid);
        quickSort(nums, mid+1, right);
    }
}

int* sortArray(int* nums, int numsSize, int* returnSize) {
    quickSort(nums, 0, numsSize - 1);
    *returnSize = numsSize;

    return nums;
}
```

